<html>



<iframe id="test_1_frame" width="700px" height="700px" src="index.html" onLoad="iframeLoaded()">
</iframe>
<div id="box_display">
</div>

<div id="inner_display">
	</div>

<textarea id="textArea" width="700px" height="40px">
</textarea>
</html>

<script>


	

	var iframe = document.getElementById("test_1_frame");
	var iframe_doc;

	function iframeLoaded() {
		iframe_doc = iframe.contentDocument;
		iframe.onmouseover = function(theEvent){mouseoverIFrame(theEvent, iframe_doc);}
	}


	var currentMouseOverIframe;

	function mouseoverIFrame(e, frame) {
		//should in fact try and show only the bottomost child when mouseover, use the html to select whole table
		var theEvent = e || frame.event;
		var target = theEvent.target || theEvent.srcElement;

		if(target == currentMouseOverIframe) {
			return;
		}

		currentMouseOverIframe = target;

		target.onclick = function() { iframeElementClicked(target, frame, iframe); };

		target.onmouseout = function() {

			target.onclick = null;
			target.onmouseout = null;
		};
	}

	function iframeElementClicked(element, framedoc, frame_node) {

		var uniqueIfameId = findUniqueIfameId(element, framedoc, frame_node);

		var tagName = element.tagName;

		switch(tagName) {
			case "p":

			case "div":

			case "span":

			case "td":

			case "tr":

			case "table":

			case "textarea":

			case "a":

			case "head":

			case "header":

			case "body":

			case default:
		}

		

	}


	//the display should be an iframe with no src
	function ElementDisplayInterface(displayNodeHead) {

		this.elementIframeId = null;

		this.elementInnerHTML = '';

		this.displayHead = displayNodeHead;

		this.setNewElement = function(iframeElement) {


			var element_clone = iframeElement.cloneNode(true);
			recursivelyAddIdTag("__DISPLAY_ELEMENT", element_clone);
			
			while( this.displayHead.hasChildNodes() ){
    			this.displayHead.removeChild(this.displayHead.lastChild);
			}


		}
	}



	function recursivelyAddIdTag(id_tag, rootElement) {

		if(rootElement==null || id_tag == null || returnArray.type != Array){
			return;
		}


		if(rootElement.hasChildNodes()){
			rootElement.childNodes.forEach(function(childNode) {
				recursiveAddIdTag(id_tag, childNode);
			});
		}
		rootElement.id.concat("__"+id_tag);
		return;
	}



	function findUniqueIfameId(element, doc, top_node) {
		var tagName = element.tagName;
		var allAttributes = element.attributes;

		var matchAttributesList = new Array();
		var reducedSearchTree = doc.getElementsByTagName(tagName);
		var tempTree;

		matchAttributesList['tagName'] = tagName;

		if(reducedSearchTree.length = 1) {
			
			return matchAttributesList;
		}

		if(element.id != null) {
			matchAttributesList['id'] = element.id;
			return matchAttributesList;
		}

		else{
			//do an armotized analysis to determine if is quicker on average to search through all attributes first
				//or all elements first
				//probably attributes due to the class function
				//can in fact pop the class attribute from the array first (if exists) and reduce the search tree immediately
			allAttributes.forEach(function(elementAttributeType) {

				matchAttributesList[elementAttributeType] = element.getAttribute(elementAttributeType);
				if(elementAttributeType == 'class') {
					tempTree = reducedSearchTree.getElementsByClassName(element.getAttribute('class'));
					reducedSearchTree = tempTree;
					tempTree = new Array();
				}
				else{
					reducedSearchTree.forEach(function(reducedElement) {
						if(reducedElement.getAttribute(elementAttributeType) != null) {
							if(reducedElement.getAttribute(elementAttributeType) == element.getAttribute(elementAttributeType)) {
								tempTree.push(reducedElement);
							}
						}
					});
					reducedSearchTree = tempTree;
					tempTree = new Array();
				}
				if(reducedSearchTree.length == 1) {
					return matchAttributesList;
				}
			});

			if(reducedSearchTree.length != 1) {
				var newList = new Array();

				if(element.parentNode == top_node) {
					//really shouldnt
					
					newList.push("REACHED_THE_TOP");
					newList.push(matchAttributesList);
				}
				else{
					newList = findUniqueIfameId(element.parentNode, doc, top_node);
					newList.push(matchAttributesList);
				}
				return newList; 
			}
			else{
				return matchAttributesList;
			}
		}
	}






	function addIframeIndicatorToAllElements() {
	}

	function mouseoverIFrame(e, frame) {
		//should in fact try and show only the bottomost child when mouseover, use the html to select whole table
		var event = e || frame.event;
		var target = event.target || event.srcElement;
		target.onclick = function() { onClickedIframeElement(target); };
	}
	function onClickedIframeElement(targetElement) {
		var uniqueAttributes = DetermineUniqueAttributes(targetElement, iframe_doc);
		if(uniqueAttributes[0] == "THERE IS NO UNIQUE") {
			//shouldnt happen
		}
		var searchTree = Array;
		var searchTreeTemp = Array;
		//will start by identifying the parent
		//no good check what arrays are accessed
		// uniqueAttributes.forEach(function(elementAttributeValue, elementAttributeType) {
		// 	if(elementAttributesToMatch.length==1) {
		// 		if(elementAttributeType == "id") {
		// 			searchTreeTemp = iframe_doc.getElementById(elementAttributeValue);
		// 		}
		// 		else{
		// 		}
		// 	}
		// });
		var currentMatch = null;
		//is the list of children
		var currentParentMatches;
		var currentMatchList;
		var currentSearchList;
		var documentTree = iframe_doc;
		var tempMatchList;
		var tempMatch;
		//for each array in unique attributes
			//for the first attribute, build list of all elements with the attribute -> will be one
			//for each of its children, check each child to match all attributes
										//build list of all children that match
										//for each of their children do the same with the next set of rules
											//repeat until reached the lowest level and all match
			//required to set rule for tables, if the nearest identifier is a table, the element can be be row/col #
		uniqueAttributes.forEach(function(matchAttributesList, matchAttributesIndex) {
			if(matchAttributesIndex == 0) {
			}
			matchAttributesList.forEach(function(attributeValue, attributeType) {
				if(attributeType == "id") {
					currentMatch = documentTree.getElementById(attributeValue);
				}
				else{
					if(attributeType == "class") {
						tempMatchList = documentTree.getElementsByClassName(attributeValue);
						if(tempMatchList.length == 1) {
							currentMatch = tempMatchList;
						}
						else{
						}
					}
				}
			});
			if(matchAttributesList.length == 1) {
				matchAttributesList
				if(matchAttributesList[0][0] == "id") {
					currentMatch = iframe_doc.getElementById(matchAttributesList[0][1]);
				}
				else if(matchAttributesList[0][0] == "class") {
					currentMatch = iframe_doc.getElementsByClassName(matchAttributesList[0][1]);
				}
				else if(matchAttributesList[0][0] == "class") {
					currentMatch = iframe_doc.getElementsByClassName(matchAttributesList[0][1]);
				}
			}
		});
		uniqueAttributes.forEach(function(elementAttributeValue, elementAttributeType) {
			if(elementAttributesToMatch.length==1) {
				if(elementAttributeType == "id") {
					searchTreeTemp = iframe_doc.getElementById(elementAttributeValue);
				}
				else{
					
				}
			}
		});
	}
	
	function escapeHtml(text) {
		var map = {
		    '&': '&amp;',
		    '<': '&lt;',
		    '>': '&gt;',
		    '"': '&quot;',
			"'": '&#039;'
		};
		return text.replace(/[&<>"']/g, function(m) { return map[m]; });
	}


	// the display shows the clicked element in the iframe
		//the display has 3 features 	-> select inner html to set attribute
		//								-> zoom in (click element to zoom) -> only if has children
		//								-> zoom out 

	// the inner html display shows the selected inner html from the display
		// can set attribute to match to vale
		// can set as identifier for attribute match


	/*
		
	When an iframe element is clicked 	-> store the clicked iframe_element
										-> set the inner html of display to the iframe_element.outterHTML
										-> 

	*/

	var theDisplay = document.getElementById("box_display");

	var innerDisplay = document.getElementById("inner_display");

	function DisplayLoaded() {
		var innerHTML = display.innerHTML;
		theDisplay.onmouseover = function(theEvent) {
			onMouseOverInDisplay(theEvent, theDisplay);
		}
	}

	function onMouseOverInDisplay(e, display) {

		var theEvent = e || display.event;
		var target = theEvent.target || theEvent.srcElement;
		target.onclick = function() { onClickedDisplayElement(target); };
		target.onmouseout = function(){ target.onclick=null; };
	}

	function onClickedDisplayElement(displayElement) {
		if(displayElement == theDisplay) {
			if(!displayElement.hasChildren()) {
				innerDisplay.innerHTML = displayElement.innerHTML;
			}
		}
		else {
			if(displayElement.hasChildren()) {
		
			}
			else{

			}
		}
	}

	function setDisplayElement(newSouce, hasChilren, isInner) {

	}


	function DisplayElementClicked(element, frameDoc) {
		//get the root inner html of the clicked element
		if(element.hasChildren()) {
			display.innerHTML = element.innerHTML;
			display.onmouseover = function(e){
				onMouseOverInDisplay(e, display)
			};
		}
	}









	function ElementDisplayOnMouseover() {

	}



	function DetermineUniqueAttributes(element, searchTree) {
		var reducedSearchTree = searchTree; 
		var elementAttributes = element.attributes;
		var attributeValue;
		var elementTagName = element.tagName;
		var attributeTypeArray = Array;
		var uniqueAttributesArray = Array;
		var arrayIndex;
		var returnArray = Array;
		//if there is id, just use this really...
		if( elementAttributes.match("id") ) {
			attributeTypeArray["id"] = element.id;
			arrayIndex = elementAttributes.indexOf("id");
			if (arrayIndex > -1) {
   				elementAttributes.splice(arrayIndex, 1);
			}
			if((reducedSearchTree = reducedSearchTree.getElementById(attributeTypeArray["id"])).length == 1)  {
			
				returnArray.push(attributeTypeArray);
				return returnArray;
			}
		}
		if( elementAttributes.match("class") ) {
			attributeTypeArray["class"] = element.class;
			arrayIndex = elementAttributes.indexOf("class");
			if (arrayIndex > -1) {
   				elementAttributes.splice(arrayIndex, 1);
			}
			if((reducedSearchTree = reducedSearchTree.getElementsByClassName(attributeTypeArray["class"])).length == 1) {
			
				returnArray.push(attributeTypeArray);
				return returnArray;
			}
		}
		//everything has a tag
		attributeTypeArray["tagName"] = element.tagName;
		if((reducedSearchTree = reducedSearchTree.getElementsByTagName(attributeTypeArray["tagName"])).length == 1) {
			returnArray.push(attributeTypeArray);
			return returnArray;
		}
		
		var tempSearchTree = Array;
		elementAttributes.forEach(function(attributeType) {
			attributeTypeArray[attributeType] = element.getAttribute(attributeType);
			reducedSearchTree.forEach(function(checkingElement, index, reducedTree) {
				if(checkingElement.getAttribute(attributeType) != null) {
					if(checkingElement.getAttribute(attributeType) == element.getAttribute(attributeType)) {
						tempSearchTree.push(checkingElement);
					}
					//do not add if the attribute does not match
				}
				//do not add if it doesnt have the attribute
			});
			reducedSearchTree = tempSearchTree;
			tempSearchTree = Array;
			if(reducedSearchTree.length == 1) {
				returnArray.push(attributeTypeArray);
				return returnArray;
			}
			//else more than one, move to next attribute type
			
		});
		//if got here there is more that needs to be done
		//run determine unique attributes on the parent
		if(element.parentNode == searchTree) {
			//well there is no unique
			returnArray.push("THERE IS NO UNIQUE");
			returnArray.push(attributeTypeArray);
			return returnArray;
		}
		else{
			returnArray = DetermineUniqueAttributes(element.parentNode, searchTree);
			returnArray.push(attributeTypeArray);
			return returnArray;
		}
	}
</script>